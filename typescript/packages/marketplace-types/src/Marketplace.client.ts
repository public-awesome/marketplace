/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult
} from "@cosmjs/cosmwasm-stargate"
import { StdFee } from "@cosmjs/amino"
import {
  Uint128,
  InstantiateMsg,
  ExpiryRange,
  Coin,
  PriceRange,
  ExecuteMsg,
  Timestamp,
  Uint64,
  QueryMsg,
  QueryOptionsForString,
  QueryOptionsForTupleOfUint128AndString,
  QueryOptionsForTupleOfStringAndString,
  QueryOptionsForTupleOfUint64AndStringAndString,
  QueryOptionsForTupleOfUint64AndStringAndStringAndString,
  NullableAsk,
  Addr,
  Decimal,
  Ask,
  ArrayOfString,
  ArrayOfAsk,
  NullableCollectionOffer,
  CollectionOffer,
  ArrayOfCollectionOffer,
  Offer,
  ArrayOfOffer,
  SudoParams
} from "./Marketplace.types"
export interface MarketplaceReadOnlyInterface {
  contractAddress: string
  sudoParams: () => Promise<SudoParams>
  ask: ({
    collection,
    tokenId
  }: {
    collection: string
    tokenId: string
  }) => Promise<NullableAsk>
  asks: ({
    collection,
    queryOptions
  }: {
    collection: string
    queryOptions?: QueryOptionsForString
  }) => Promise<ArrayOfAsk>
  asksByPrice: ({
    collection,
    denom,
    queryOptions
  }: {
    collection: string
    denom: string
    queryOptions?: QueryOptionsForTupleOfUint128AndString
  }) => Promise<ArrayOfAsk>
  asksBySeller: ({
    queryOptions,
    seller
  }: {
    queryOptions?: QueryOptionsForTupleOfStringAndString
    seller: string
  }) => Promise<ArrayOfAsk>
  asksByExpiration: ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForTupleOfUint64AndStringAndString
  }) => Promise<ArrayOfAsk>
  offer: ({
    bidder,
    collection,
    tokenId
  }: {
    bidder: string
    collection: string
    tokenId: string
  }) => Promise<Offer>
  offersByCollection: ({
    collection,
    queryOptions
  }: {
    collection: string
    queryOptions?: QueryOptionsForTupleOfStringAndString
  }) => Promise<ArrayOfOffer>
  offersByTokenPrice: ({
    collection,
    denom,
    queryOptions,
    tokenId
  }: {
    collection: string
    denom: string
    queryOptions?: QueryOptionsForTupleOfUint128AndString
    tokenId: string
  }) => Promise<ArrayOfOffer>
  offersByBidder: ({
    bidder,
    queryOptions
  }: {
    bidder: string
    queryOptions?: QueryOptionsForTupleOfStringAndString
  }) => Promise<ArrayOfOffer>
  offersByExpiration: ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForTupleOfUint64AndStringAndStringAndString
  }) => Promise<ArrayOfOffer>
  collectionOffer: ({
    bidder,
    collection
  }: {
    bidder: string
    collection: string
  }) => Promise<NullableCollectionOffer>
  collectionOffersByPrice: ({
    collection,
    denom,
    queryOptions
  }: {
    collection: string
    denom: string
    queryOptions?: QueryOptionsForTupleOfUint128AndString
  }) => Promise<ArrayOfCollectionOffer>
  collectionOffersByBidder: ({
    bidder,
    queryOptions
  }: {
    bidder: string
    queryOptions?: QueryOptionsForString
  }) => Promise<ArrayOfCollectionOffer>
  collectionOffersByExpiration: ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForTupleOfUint64AndStringAndString
  }) => Promise<ArrayOfCollectionOffer>
  askHooks: () => Promise<ArrayOfString>
  offerHooks: () => Promise<ArrayOfString>
  saleHooks: () => Promise<ArrayOfString>
}
export class MarketplaceQueryClient implements MarketplaceReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.sudoParams = this.sudoParams.bind(this)
    this.ask = this.ask.bind(this)
    this.asks = this.asks.bind(this)
    this.asksByPrice = this.asksByPrice.bind(this)
    this.asksBySeller = this.asksBySeller.bind(this)
    this.asksByExpiration = this.asksByExpiration.bind(this)
    this.offer = this.offer.bind(this)
    this.offersByCollection = this.offersByCollection.bind(this)
    this.offersByTokenPrice = this.offersByTokenPrice.bind(this)
    this.offersByBidder = this.offersByBidder.bind(this)
    this.offersByExpiration = this.offersByExpiration.bind(this)
    this.collectionOffer = this.collectionOffer.bind(this)
    this.collectionOffersByPrice = this.collectionOffersByPrice.bind(this)
    this.collectionOffersByBidder = this.collectionOffersByBidder.bind(this)
    this.collectionOffersByExpiration =
      this.collectionOffersByExpiration.bind(this)
    this.askHooks = this.askHooks.bind(this)
    this.offerHooks = this.offerHooks.bind(this)
    this.saleHooks = this.saleHooks.bind(this)
  }

  sudoParams = async (): Promise<SudoParams> => {
    return this.client.queryContractSmart(this.contractAddress, {
      sudo_params: {}
    })
  }
  ask = async ({
    collection,
    tokenId
  }: {
    collection: string
    tokenId: string
  }): Promise<NullableAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ask: {
        collection,
        token_id: tokenId
      }
    })
  }
  asks = async ({
    collection,
    queryOptions
  }: {
    collection: string
    queryOptions?: QueryOptionsForString
  }): Promise<ArrayOfAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks: {
        collection,
        query_options: queryOptions
      }
    })
  }
  asksByPrice = async ({
    collection,
    denom,
    queryOptions
  }: {
    collection: string
    denom: string
    queryOptions?: QueryOptionsForTupleOfUint128AndString
  }): Promise<ArrayOfAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_by_price: {
        collection,
        denom,
        query_options: queryOptions
      }
    })
  }
  asksBySeller = async ({
    queryOptions,
    seller
  }: {
    queryOptions?: QueryOptionsForTupleOfStringAndString
    seller: string
  }): Promise<ArrayOfAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_by_seller: {
        query_options: queryOptions,
        seller
      }
    })
  }
  asksByExpiration = async ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForTupleOfUint64AndStringAndString
  }): Promise<ArrayOfAsk> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_by_expiration: {
        query_options: queryOptions
      }
    })
  }
  offer = async ({
    bidder,
    collection,
    tokenId
  }: {
    bidder: string
    collection: string
    tokenId: string
  }): Promise<Offer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offer: {
        bidder,
        collection,
        token_id: tokenId
      }
    })
  }
  offersByCollection = async ({
    collection,
    queryOptions
  }: {
    collection: string
    queryOptions?: QueryOptionsForTupleOfStringAndString
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offers_by_collection: {
        collection,
        query_options: queryOptions
      }
    })
  }
  offersByTokenPrice = async ({
    collection,
    denom,
    queryOptions,
    tokenId
  }: {
    collection: string
    denom: string
    queryOptions?: QueryOptionsForTupleOfUint128AndString
    tokenId: string
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offers_by_token_price: {
        collection,
        denom,
        query_options: queryOptions,
        token_id: tokenId
      }
    })
  }
  offersByBidder = async ({
    bidder,
    queryOptions
  }: {
    bidder: string
    queryOptions?: QueryOptionsForTupleOfStringAndString
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offers_by_bidder: {
        bidder,
        query_options: queryOptions
      }
    })
  }
  offersByExpiration = async ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForTupleOfUint64AndStringAndStringAndString
  }): Promise<ArrayOfOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offers_by_expiration: {
        query_options: queryOptions
      }
    })
  }
  collectionOffer = async ({
    bidder,
    collection
  }: {
    bidder: string
    collection: string
  }): Promise<NullableCollectionOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offer: {
        bidder,
        collection
      }
    })
  }
  collectionOffersByPrice = async ({
    collection,
    denom,
    queryOptions
  }: {
    collection: string
    denom: string
    queryOptions?: QueryOptionsForTupleOfUint128AndString
  }): Promise<ArrayOfCollectionOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offers_by_price: {
        collection,
        denom,
        query_options: queryOptions
      }
    })
  }
  collectionOffersByBidder = async ({
    bidder,
    queryOptions
  }: {
    bidder: string
    queryOptions?: QueryOptionsForString
  }): Promise<ArrayOfCollectionOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offers_by_bidder: {
        bidder,
        query_options: queryOptions
      }
    })
  }
  collectionOffersByExpiration = async ({
    queryOptions
  }: {
    queryOptions?: QueryOptionsForTupleOfUint64AndStringAndString
  }): Promise<ArrayOfCollectionOffer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_offers_by_expiration: {
        query_options: queryOptions
      }
    })
  }
  askHooks = async (): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ask_hooks: {}
    })
  }
  offerHooks = async (): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      offer_hooks: {}
    })
  }
  saleHooks = async (): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      sale_hooks: {}
    })
  }
}
export interface MarketplaceInterface extends MarketplaceReadOnlyInterface {
  contractAddress: string
  sender: string
  setAsk: (
    {
      assetRecipient,
      collection,
      expires,
      findersFeeBps,
      price,
      reserveFor,
      tokenId
    }: {
      assetRecipient?: string
      collection: string
      expires?: Timestamp
      findersFeeBps?: number
      price: Coin
      reserveFor?: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  updateAskPrice: (
    {
      collection,
      price,
      tokenId
    }: {
      collection: string
      price: Coin
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeAsk: (
    {
      collection,
      tokenId
    }: {
      collection: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeStaleAsk: (
    {
      collection,
      tokenId
    }: {
      collection: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  migrateAsks: (
    {
      limit
    }: {
      limit: number
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  setOffer: (
    {
      assetRecipient,
      collection,
      expires,
      finder,
      findersFeeBps,
      tokenId
    }: {
      assetRecipient?: string
      collection: string
      expires?: Timestamp
      finder?: string
      findersFeeBps?: number
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  buyNow: (
    {
      assetRecipient,
      collection,
      finder,
      tokenId
    }: {
      assetRecipient?: string
      collection: string
      finder?: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  acceptOffer: (
    {
      assetRecipient,
      bidder,
      collection,
      finder,
      tokenId
    }: {
      assetRecipient?: string
      bidder: string
      collection: string
      finder?: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeOffer: (
    {
      collection,
      tokenId
    }: {
      collection: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  rejectOffer: (
    {
      bidder,
      collection,
      tokenId
    }: {
      bidder: string
      collection: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeStaleOffer: (
    {
      bidder,
      collection,
      tokenId
    }: {
      bidder: string
      collection: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  migrateOffers: (
    {
      limit
    }: {
      limit: number
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  setCollectionOffer: (
    {
      assetRecipient,
      collection,
      expires,
      findersFeeBps
    }: {
      assetRecipient?: string
      collection: string
      expires?: Timestamp
      findersFeeBps?: number
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  acceptCollectionOffer: (
    {
      assetRecipient,
      bidder,
      collection,
      finder,
      tokenId
    }: {
      assetRecipient?: string
      bidder: string
      collection: string
      finder?: string
      tokenId: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeCollectionOffer: (
    {
      collection
    }: {
      collection: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeStaleCollectionOffer: (
    {
      bidder,
      collection
    }: {
      bidder: string
      collection: string
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  migrateCollectionOffers: (
    {
      limit
    }: {
      limit: number
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
}
export class MarketplaceClient
  extends MarketplaceQueryClient
  implements MarketplaceInterface
{
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.setAsk = this.setAsk.bind(this)
    this.updateAskPrice = this.updateAskPrice.bind(this)
    this.removeAsk = this.removeAsk.bind(this)
    this.removeStaleAsk = this.removeStaleAsk.bind(this)
    this.migrateAsks = this.migrateAsks.bind(this)
    this.setOffer = this.setOffer.bind(this)
    this.buyNow = this.buyNow.bind(this)
    this.acceptOffer = this.acceptOffer.bind(this)
    this.removeOffer = this.removeOffer.bind(this)
    this.rejectOffer = this.rejectOffer.bind(this)
    this.removeStaleOffer = this.removeStaleOffer.bind(this)
    this.migrateOffers = this.migrateOffers.bind(this)
    this.setCollectionOffer = this.setCollectionOffer.bind(this)
    this.acceptCollectionOffer = this.acceptCollectionOffer.bind(this)
    this.removeCollectionOffer = this.removeCollectionOffer.bind(this)
    this.removeStaleCollectionOffer = this.removeStaleCollectionOffer.bind(this)
    this.migrateCollectionOffers = this.migrateCollectionOffers.bind(this)
  }

  setAsk = async (
    {
      assetRecipient,
      collection,
      expires,
      findersFeeBps,
      price,
      reserveFor,
      tokenId
    }: {
      assetRecipient?: string
      collection: string
      expires?: Timestamp
      findersFeeBps?: number
      price: Coin
      reserveFor?: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_ask: {
          asset_recipient: assetRecipient,
          collection,
          expires,
          finders_fee_bps: findersFeeBps,
          price,
          reserve_for: reserveFor,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  updateAskPrice = async (
    {
      collection,
      price,
      tokenId
    }: {
      collection: string
      price: Coin
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_ask_price: {
          collection,
          price,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  removeAsk = async (
    {
      collection,
      tokenId
    }: {
      collection: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_ask: {
          collection,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  removeStaleAsk = async (
    {
      collection,
      tokenId
    }: {
      collection: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_stale_ask: {
          collection,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  migrateAsks = async (
    {
      limit
    }: {
      limit: number
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        migrate_asks: {
          limit
        }
      },
      fee,
      memo,
      funds
    )
  }
  setOffer = async (
    {
      assetRecipient,
      collection,
      expires,
      finder,
      findersFeeBps,
      tokenId
    }: {
      assetRecipient?: string
      collection: string
      expires?: Timestamp
      finder?: string
      findersFeeBps?: number
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_offer: {
          asset_recipient: assetRecipient,
          collection,
          expires,
          finder,
          finders_fee_bps: findersFeeBps,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  buyNow = async (
    {
      assetRecipient,
      collection,
      finder,
      tokenId
    }: {
      assetRecipient?: string
      collection: string
      finder?: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        buy_now: {
          asset_recipient: assetRecipient,
          collection,
          finder,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  acceptOffer = async (
    {
      assetRecipient,
      bidder,
      collection,
      finder,
      tokenId
    }: {
      assetRecipient?: string
      bidder: string
      collection: string
      finder?: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        accept_offer: {
          asset_recipient: assetRecipient,
          bidder,
          collection,
          finder,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  removeOffer = async (
    {
      collection,
      tokenId
    }: {
      collection: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_offer: {
          collection,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  rejectOffer = async (
    {
      bidder,
      collection,
      tokenId
    }: {
      bidder: string
      collection: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        reject_offer: {
          bidder,
          collection,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  removeStaleOffer = async (
    {
      bidder,
      collection,
      tokenId
    }: {
      bidder: string
      collection: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_stale_offer: {
          bidder,
          collection,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  migrateOffers = async (
    {
      limit
    }: {
      limit: number
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        migrate_offers: {
          limit
        }
      },
      fee,
      memo,
      funds
    )
  }
  setCollectionOffer = async (
    {
      assetRecipient,
      collection,
      expires,
      findersFeeBps
    }: {
      assetRecipient?: string
      collection: string
      expires?: Timestamp
      findersFeeBps?: number
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_collection_offer: {
          asset_recipient: assetRecipient,
          collection,
          expires,
          finders_fee_bps: findersFeeBps
        }
      },
      fee,
      memo,
      funds
    )
  }
  acceptCollectionOffer = async (
    {
      assetRecipient,
      bidder,
      collection,
      finder,
      tokenId
    }: {
      assetRecipient?: string
      bidder: string
      collection: string
      finder?: string
      tokenId: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        accept_collection_offer: {
          asset_recipient: assetRecipient,
          bidder,
          collection,
          finder,
          token_id: tokenId
        }
      },
      fee,
      memo,
      funds
    )
  }
  removeCollectionOffer = async (
    {
      collection
    }: {
      collection: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_collection_offer: {
          collection
        }
      },
      fee,
      memo,
      funds
    )
  }
  removeStaleCollectionOffer = async (
    {
      bidder,
      collection
    }: {
      bidder: string
      collection: string
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_stale_collection_offer: {
          bidder,
          collection
        }
      },
      fee,
      memo,
      funds
    )
  }
  migrateCollectionOffers = async (
    {
      limit
    }: {
      limit: number
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        migrate_collection_offers: {
          limit
        }
      },
      fee,
      memo,
      funds
    )
  }
}
