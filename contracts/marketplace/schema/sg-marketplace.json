{
  "contract_name": "sg-marketplace",
  "contract_version": "1.5.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "ask_expiry",
      "fair_burn",
      "listing_fee",
      "max_asks_removed_per_block",
      "max_collection_offers_removed_per_block",
      "max_finders_fee_bps",
      "max_offers_removed_per_block",
      "offer_expiry",
      "operators",
      "price_ranges",
      "removal_reward_bps",
      "trading_fee_bps"
    ],
    "properties": {
      "ask_expiry": {
        "description": "Valid time range for Asks (min, max) in seconds",
        "allOf": [
          {
            "$ref": "#/definitions/ExpiryRange"
          }
        ]
      },
      "fair_burn": {
        "description": "The address of the fair burn contract",
        "type": "string"
      },
      "listing_fee": {
        "description": "Listing fee to reduce spam",
        "allOf": [
          {
            "$ref": "#/definitions/Coin"
          }
        ]
      },
      "max_asks_removed_per_block": {
        "description": "The maximum number of asks that can be removed per block",
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "max_collection_offers_removed_per_block": {
        "description": "The maximum number of collection offers that can be removed per block",
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "max_finders_fee_bps": {
        "description": "Max basis points for the finders fee",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "max_offers_removed_per_block": {
        "description": "The maximum number of offers that can be removed per block",
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "offer_expiry": {
        "description": "Valid time range for offers (min, max) in seconds",
        "allOf": [
          {
            "$ref": "#/definitions/ExpiryRange"
          }
        ]
      },
      "operators": {
        "description": "Operators are entites that are responsible for maintaining the active state of Asks. They listen to NFT transfer events, and update the active state of Asks.",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "price_ranges": {
        "description": "Min/max values for offers and asks",
        "type": "array",
        "items": {
          "type": "array",
          "items": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/PriceRange"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "removal_reward_bps": {
        "description": "Expired offer / ask removal reward",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "sale_hook": {
        "description": "The address of the airdrop claim contract to detect sales",
        "type": [
          "string",
          "null"
        ]
      },
      "trading_fee_bps": {
        "description": "Fair Burn fee 0.25% = 25, 0.5% = 50, 1% = 100, 2.5% = 250",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "ExpiryRange": {
        "type": "object",
        "required": [
          "max",
          "min"
        ],
        "properties": {
          "max": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "min": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "PriceRange": {
        "type": "object",
        "required": [
          "max",
          "min"
        ],
        "properties": {
          "max": {
            "$ref": "#/definitions/Uint128"
          },
          "min": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "List an NFT on the marketplace by creating a new ask",
        "type": "object",
        "required": [
          "set_ask"
        ],
        "properties": {
          "set_ask": {
            "type": "object",
            "required": [
              "collection",
              "price",
              "token_id"
            ],
            "properties": {
              "asset_recipient": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "collection": {
                "type": "string"
              },
              "expires": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Timestamp"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "finders_fee_bps": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "price": {
                "$ref": "#/definitions/Coin"
              },
              "reserve_for": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the price of an existing ask",
        "type": "object",
        "required": [
          "update_ask_price"
        ],
        "properties": {
          "update_ask_price": {
            "type": "object",
            "required": [
              "collection",
              "price",
              "token_id"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "price": {
                "$ref": "#/definitions/Coin"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove an existing ask from the marketplace",
        "type": "object",
        "required": [
          "remove_ask"
        ],
        "properties": {
          "remove_ask": {
            "type": "object",
            "required": [
              "collection",
              "token_id"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Privileged operation to remove stale or invalid asks.",
        "type": "object",
        "required": [
          "remove_stale_ask"
        ],
        "properties": {
          "remove_stale_ask": {
            "type": "object",
            "required": [
              "collection",
              "token_id"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Migrate ask to v3 Ask",
        "type": "object",
        "required": [
          "migrate_asks"
        ],
        "properties": {
          "migrate_asks": {
            "type": "object",
            "required": [
              "limit"
            ],
            "properties": {
              "limit": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Create an offer for an NFT",
        "type": "object",
        "required": [
          "set_offer"
        ],
        "properties": {
          "set_offer": {
            "type": "object",
            "required": [
              "collection",
              "token_id"
            ],
            "properties": {
              "asset_recipient": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "collection": {
                "type": "string"
              },
              "expires": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Timestamp"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "finder": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "finders_fee_bps": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Buy an NFT from the marketplace",
        "type": "object",
        "required": [
          "buy_now"
        ],
        "properties": {
          "buy_now": {
            "type": "object",
            "required": [
              "collection",
              "token_id"
            ],
            "properties": {
              "asset_recipient": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "collection": {
                "type": "string"
              },
              "finder": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Accept a offer on an existing ask",
        "type": "object",
        "required": [
          "accept_offer"
        ],
        "properties": {
          "accept_offer": {
            "type": "object",
            "required": [
              "bidder",
              "collection",
              "token_id"
            ],
            "properties": {
              "asset_recipient": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "bidder": {
                "type": "string"
              },
              "collection": {
                "type": "string"
              },
              "finder": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove an existing offer from an ask",
        "type": "object",
        "required": [
          "remove_offer"
        ],
        "properties": {
          "remove_offer": {
            "type": "object",
            "required": [
              "collection",
              "token_id"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Reject a offer on an existing ask",
        "type": "object",
        "required": [
          "reject_offer"
        ],
        "properties": {
          "reject_offer": {
            "type": "object",
            "required": [
              "bidder",
              "collection",
              "token_id"
            ],
            "properties": {
              "bidder": {
                "type": "string"
              },
              "collection": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove an existing offer from an ask",
        "type": "object",
        "required": [
          "remove_stale_offer"
        ],
        "properties": {
          "remove_stale_offer": {
            "type": "object",
            "required": [
              "bidder",
              "collection",
              "token_id"
            ],
            "properties": {
              "bidder": {
                "type": "string"
              },
              "collection": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Migrate Bids to V3 Offers",
        "type": "object",
        "required": [
          "migrate_offers"
        ],
        "properties": {
          "migrate_offers": {
            "type": "object",
            "required": [
              "limit"
            ],
            "properties": {
              "limit": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Place an offer (limit order) across an entire collection",
        "type": "object",
        "required": [
          "set_collection_offer"
        ],
        "properties": {
          "set_collection_offer": {
            "type": "object",
            "required": [
              "collection"
            ],
            "properties": {
              "asset_recipient": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "collection": {
                "type": "string"
              },
              "expires": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Timestamp"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "finders_fee_bps": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Accept a collection offer",
        "type": "object",
        "required": [
          "accept_collection_offer"
        ],
        "properties": {
          "accept_collection_offer": {
            "type": "object",
            "required": [
              "bidder",
              "collection",
              "token_id"
            ],
            "properties": {
              "asset_recipient": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "bidder": {
                "type": "string"
              },
              "collection": {
                "type": "string"
              },
              "finder": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove a offer (limit order) across an entire collection",
        "type": "object",
        "required": [
          "remove_collection_offer"
        ],
        "properties": {
          "remove_collection_offer": {
            "type": "object",
            "required": [
              "collection"
            ],
            "properties": {
              "collection": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove a offer (limit order) across an entire collection",
        "type": "object",
        "required": [
          "remove_stale_collection_offer"
        ],
        "properties": {
          "remove_stale_collection_offer": {
            "type": "object",
            "required": [
              "bidder",
              "collection"
            ],
            "properties": {
              "bidder": {
                "type": "string"
              },
              "collection": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Migrate CollectionBids to V3 CollectionOffers",
        "type": "object",
        "required": [
          "migrate_collection_offers"
        ],
        "properties": {
          "migrate_collection_offers": {
            "type": "object",
            "required": [
              "limit"
            ],
            "properties": {
              "limit": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Get the config for the contract",
        "type": "object",
        "required": [
          "sudo_params"
        ],
        "properties": {
          "sudo_params": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get the current ask for specific NFT",
        "type": "object",
        "required": [
          "ask"
        ],
        "properties": {
          "ask": {
            "type": "object",
            "required": [
              "collection",
              "token_id"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all asks for a collection",
        "type": "object",
        "required": [
          "asks"
        ],
        "properties": {
          "asks": {
            "type": "object",
            "required": [
              "collection"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all asks for a collection, sorted by price",
        "type": "object",
        "required": [
          "asks_by_price"
        ],
        "properties": {
          "asks_by_price": {
            "type": "object",
            "required": [
              "collection",
              "denom"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_uint128_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all asks by seller",
        "type": "object",
        "required": [
          "asks_by_seller"
        ],
        "properties": {
          "asks_by_seller": {
            "type": "object",
            "required": [
              "seller"
            ],
            "properties": {
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_String_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "seller": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all asks sorted by the expiration time",
        "type": "object",
        "required": [
          "asks_by_expiration"
        ],
        "properties": {
          "asks_by_expiration": {
            "type": "object",
            "properties": {
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_uint64_and_String_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get data for a specific offer",
        "type": "object",
        "required": [
          "offer"
        ],
        "properties": {
          "offer": {
            "type": "object",
            "required": [
              "bidder",
              "collection",
              "token_id"
            ],
            "properties": {
              "bidder": {
                "type": "string"
              },
              "collection": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all offers on a collection",
        "type": "object",
        "required": [
          "offers_by_collection"
        ],
        "properties": {
          "offers_by_collection": {
            "type": "object",
            "required": [
              "collection"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_String_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all offers on a collection token, sorted by price",
        "type": "object",
        "required": [
          "offers_by_token_price"
        ],
        "properties": {
          "offers_by_token_price": {
            "type": "object",
            "required": [
              "collection",
              "denom",
              "token_id"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_uint128_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all offers made by a bidder",
        "type": "object",
        "required": [
          "offers_by_bidder"
        ],
        "properties": {
          "offers_by_bidder": {
            "type": "object",
            "required": [
              "bidder"
            ],
            "properties": {
              "bidder": {
                "type": "string"
              },
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_String_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all offers sorted by the expiration time",
        "type": "object",
        "required": [
          "offers_by_expiration"
        ],
        "properties": {
          "offers_by_expiration": {
            "type": "object",
            "properties": {
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_uint64_and_String_and_String_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get data for a specific collection offer",
        "type": "object",
        "required": [
          "collection_offer"
        ],
        "properties": {
          "collection_offer": {
            "type": "object",
            "required": [
              "bidder",
              "collection"
            ],
            "properties": {
              "bidder": {
                "type": "string"
              },
              "collection": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all collection offers for a collection, sorted by price",
        "type": "object",
        "required": [
          "collection_offers_by_price"
        ],
        "properties": {
          "collection_offers_by_price": {
            "type": "object",
            "required": [
              "collection",
              "denom"
            ],
            "properties": {
              "collection": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_uint128_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all collection offers made by a bidder",
        "type": "object",
        "required": [
          "collection_offers_by_bidder"
        ],
        "properties": {
          "collection_offers_by_bidder": {
            "type": "object",
            "required": [
              "bidder"
            ],
            "properties": {
              "bidder": {
                "type": "string"
              },
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get all collection offers sorted by the expiration time",
        "type": "object",
        "required": [
          "collection_offers_by_expiration"
        ],
        "properties": {
          "collection_offers_by_expiration": {
            "type": "object",
            "properties": {
              "query_options": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryOptions_for_Tuple_of_uint64_and_String_and_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Show all registered ask hooks",
        "type": "object",
        "required": [
          "ask_hooks"
        ],
        "properties": {
          "ask_hooks": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Show all registered bid hooks",
        "type": "object",
        "required": [
          "offer_hooks"
        ],
        "properties": {
          "offer_hooks": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Show all registered sale hooks",
        "type": "object",
        "required": [
          "sale_hooks"
        ],
        "properties": {
          "sale_hooks": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "QueryOptions_for_String": {
        "description": "QueryOptions are used to paginate contract queries",
        "type": "object",
        "properties": {
          "descending": {
            "description": "Whether to sort items in ascending or descending order",
            "type": [
              "boolean",
              "null"
            ]
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "start_after": {
            "description": "The key to start the query after",
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "QueryOptions_for_Tuple_of_String_and_String": {
        "description": "QueryOptions are used to paginate contract queries",
        "type": "object",
        "properties": {
          "descending": {
            "description": "Whether to sort items in ascending or descending order",
            "type": [
              "boolean",
              "null"
            ]
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "start_after": {
            "description": "The key to start the query after",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "type": "string"
              },
              {
                "type": "string"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "additionalProperties": false
      },
      "QueryOptions_for_Tuple_of_uint128_and_String": {
        "description": "QueryOptions are used to paginate contract queries",
        "type": "object",
        "properties": {
          "descending": {
            "description": "Whether to sort items in ascending or descending order",
            "type": [
              "boolean",
              "null"
            ]
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "start_after": {
            "description": "The key to start the query after",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "type": "integer",
                "format": "uint128",
                "minimum": 0.0
              },
              {
                "type": "string"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "additionalProperties": false
      },
      "QueryOptions_for_Tuple_of_uint64_and_String_and_String": {
        "description": "QueryOptions are used to paginate contract queries",
        "type": "object",
        "properties": {
          "descending": {
            "description": "Whether to sort items in ascending or descending order",
            "type": [
              "boolean",
              "null"
            ]
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "start_after": {
            "description": "The key to start the query after",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              {
                "type": "string"
              },
              {
                "type": "string"
              }
            ],
            "maxItems": 3,
            "minItems": 3
          }
        },
        "additionalProperties": false
      },
      "QueryOptions_for_Tuple_of_uint64_and_String_and_String_and_String": {
        "description": "QueryOptions are used to paginate contract queries",
        "type": "object",
        "properties": {
          "descending": {
            "description": "Whether to sort items in ascending or descending order",
            "type": [
              "boolean",
              "null"
            ]
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "start_after": {
            "description": "The key to start the query after",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              {
                "type": "string"
              },
              {
                "type": "string"
              },
              {
                "type": "string"
              }
            ],
            "maxItems": 4,
            "minItems": 4
          }
        },
        "additionalProperties": false
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "ask": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_Ask",
      "anyOf": [
        {
          "$ref": "#/definitions/Ask"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Ask": {
          "description": "Represents an ask on the marketplace",
          "type": "object",
          "required": [
            "collection",
            "price",
            "seller",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "paid_removal_fee": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Coin"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "reserve_for": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "seller": {
              "$ref": "#/definitions/Addr"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "ask_hooks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "asks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Ask",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Ask"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Ask": {
          "description": "Represents an ask on the marketplace",
          "type": "object",
          "required": [
            "collection",
            "price",
            "seller",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "paid_removal_fee": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Coin"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "reserve_for": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "seller": {
              "$ref": "#/definitions/Addr"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "asks_by_expiration": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Ask",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Ask"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Ask": {
          "description": "Represents an ask on the marketplace",
          "type": "object",
          "required": [
            "collection",
            "price",
            "seller",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "paid_removal_fee": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Coin"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "reserve_for": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "seller": {
              "$ref": "#/definitions/Addr"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "asks_by_price": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Ask",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Ask"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Ask": {
          "description": "Represents an ask on the marketplace",
          "type": "object",
          "required": [
            "collection",
            "price",
            "seller",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "paid_removal_fee": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Coin"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "reserve_for": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "seller": {
              "$ref": "#/definitions/Addr"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "asks_by_seller": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Ask",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Ask"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Ask": {
          "description": "Represents an ask on the marketplace",
          "type": "object",
          "required": [
            "collection",
            "price",
            "seller",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "paid_removal_fee": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Coin"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "reserve_for": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "seller": {
              "$ref": "#/definitions/Addr"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "collection_offer": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_CollectionOffer",
      "anyOf": [
        {
          "$ref": "#/definitions/CollectionOffer"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "CollectionOffer": {
          "description": "Represents an offer across an entire collection in the marketplace",
          "type": "object",
          "required": [
            "bidder",
            "collection",
            "price"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "bidder": {
              "$ref": "#/definitions/Addr"
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "collection_offers_by_bidder": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_CollectionOffer",
      "type": "array",
      "items": {
        "$ref": "#/definitions/CollectionOffer"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "CollectionOffer": {
          "description": "Represents an offer across an entire collection in the marketplace",
          "type": "object",
          "required": [
            "bidder",
            "collection",
            "price"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "bidder": {
              "$ref": "#/definitions/Addr"
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "collection_offers_by_expiration": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_CollectionOffer",
      "type": "array",
      "items": {
        "$ref": "#/definitions/CollectionOffer"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "CollectionOffer": {
          "description": "Represents an offer across an entire collection in the marketplace",
          "type": "object",
          "required": [
            "bidder",
            "collection",
            "price"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "bidder": {
              "$ref": "#/definitions/Addr"
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "collection_offers_by_price": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_CollectionOffer",
      "type": "array",
      "items": {
        "$ref": "#/definitions/CollectionOffer"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "CollectionOffer": {
          "description": "Represents an offer across an entire collection in the marketplace",
          "type": "object",
          "required": [
            "bidder",
            "collection",
            "price"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "bidder": {
              "$ref": "#/definitions/Addr"
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "offer": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Offer",
      "description": "Represents an offer on an NFT in the marketplace",
      "type": "object",
      "required": [
        "bidder",
        "collection",
        "price",
        "token_id"
      ],
      "properties": {
        "asset_recipient": {
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "bidder": {
          "$ref": "#/definitions/Addr"
        },
        "collection": {
          "$ref": "#/definitions/Addr"
        },
        "expires": {
          "anyOf": [
            {
              "$ref": "#/definitions/Timestamp"
            },
            {
              "type": "null"
            }
          ]
        },
        "finders_fee_percent": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "price": {
          "$ref": "#/definitions/Coin"
        },
        "token_id": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "offer_hooks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "offers_by_bidder": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Offer",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Offer"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Offer": {
          "description": "Represents an offer on an NFT in the marketplace",
          "type": "object",
          "required": [
            "bidder",
            "collection",
            "price",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "bidder": {
              "$ref": "#/definitions/Addr"
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "offers_by_collection": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Offer",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Offer"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Offer": {
          "description": "Represents an offer on an NFT in the marketplace",
          "type": "object",
          "required": [
            "bidder",
            "collection",
            "price",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "bidder": {
              "$ref": "#/definitions/Addr"
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "offers_by_expiration": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Offer",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Offer"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Offer": {
          "description": "Represents an offer on an NFT in the marketplace",
          "type": "object",
          "required": [
            "bidder",
            "collection",
            "price",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "bidder": {
              "$ref": "#/definitions/Addr"
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "offers_by_token_price": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Offer",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Offer"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Offer": {
          "description": "Represents an offer on an NFT in the marketplace",
          "type": "object",
          "required": [
            "bidder",
            "collection",
            "price",
            "token_id"
          ],
          "properties": {
            "asset_recipient": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "bidder": {
              "$ref": "#/definitions/Addr"
            },
            "collection": {
              "$ref": "#/definitions/Addr"
            },
            "expires": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            },
            "finders_fee_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "price": {
              "$ref": "#/definitions/Coin"
            },
            "token_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "sale_hooks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "sudo_params": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SudoParams",
      "type": "object",
      "required": [
        "ask_expiry",
        "fair_burn",
        "listing_fee",
        "max_asks_removed_per_block",
        "max_collection_offers_removed_per_block",
        "max_finders_fee_percent",
        "max_offers_removed_per_block",
        "offer_expiry",
        "operators",
        "removal_reward_percent",
        "trading_fee_percent"
      ],
      "properties": {
        "ask_expiry": {
          "description": "Valid time range for Asks (min, max) in seconds",
          "allOf": [
            {
              "$ref": "#/definitions/ExpiryRange"
            }
          ]
        },
        "fair_burn": {
          "description": "The address of the fair burn contract",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "listing_fee": {
          "description": "Listing fee to reduce spam",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "max_asks_removed_per_block": {
          "description": "The maximum number of asks that can be removed per block",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "max_collection_offers_removed_per_block": {
          "description": "The maximum number of collection offers that can be removed per block",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "max_finders_fee_percent": {
          "description": "Max value for the finders fee",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "max_offers_removed_per_block": {
          "description": "The maximum number of offers that can be removed per block",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "offer_expiry": {
          "description": "Valid time range for offers (min, max) in seconds",
          "allOf": [
            {
              "$ref": "#/definitions/ExpiryRange"
            }
          ]
        },
        "operators": {
          "description": "Operators are entites that are responsible for maintaining the active state of Asks They listen to NFT transfer events, and update the active state of Asks",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Addr"
          }
        },
        "removal_reward_percent": {
          "description": "Stale offer / ask removal reward",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "trading_fee_percent": {
          "description": "Fair Burn fee",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "ExpiryRange": {
          "type": "object",
          "required": [
            "max",
            "min"
          ],
          "properties": {
            "max": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "min": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
